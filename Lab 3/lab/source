import numpy as np
from PIL import Image

#15
def rotate_and_shift_rabbit(tx, ty, tz, a, b, c, x, y, z):
    help_matrix1 = np.array([[1, 0, 0], [0, np.cos(a), np.sin(a)], [0, -np.sin(a), np.cos(a)]])
    help_matrix2 = np.array([[np.cos(b), 0, np.sin(b)], [0, 1, 0], [-np.sin(b), 0, np.cos(b)]])
    help_matrix3 = np.array([[np.cos(c), np.sin(c), 0], [-np.sin(c), np.cos(c), 0], [0, 0, 1]])
    r = np.dot((np.dot(help_matrix1, help_matrix2)), help_matrix3)
    coord_matrix = np.array([x, y, z])
    first_term = np.dot(r, coord_matrix)
    shift_matrix = np.array([tx, ty, tz])
    new_coord_matrix = first_term + shift_matrix
    return new_coord_matrix[0], new_coord_matrix[1], new_coord_matrix[2]

#12
def cos_of_light(normal_vec, l = [0, 0, 1]):
    return ((np.dot(normal_vec, l)) / (np.linalg.norm(normal_vec) * np.linalg.norm(l)))

#17
def vertex_normals(vertices, polygons):
    vertex_normals = []
    polygons_count = []
    for i in range(len(vertices)):
        normal_vec = np.array([0.0, 0.0, 0.0])
        vertex_normals.append(normal_vec)
        polygons_count.append(0)
    
    for polygon in polygons:
        idx1 = polygon[0] - 1
        idx2 = polygon[1] - 1
        idx3 = polygon[2] - 1
        v1 = np.array(vertices[idx1])
        v2 = np.array(vertices[idx2])
        v3 = np.array(vertices[idx3])
        normal_vec = np.cross(v2 - v1, v3 - v1)
        normal_length = np.linalg.norm(normal_vec)
        if(normal_length > 0):
            normal_vec /= normal_length
        vertex_normals[idx1] += normal_vec
        vertex_normals[idx2] += normal_vec
        vertex_normals[idx3] += normal_vec
        polygons_count[idx1] += 1
        polygons_count[idx2] += 1
        polygons_count[idx3] += 1

    for i in range(len(vertex_normals)):
        if (polygons_count[i] > 0):
            vertex_normals[i] = vertex_normals[i] / polygons_count[i]
            length = np.linalg.norm(vertex_normals[i])
            if (length > 0):
                vertex_normals[i] = vertex_normals[i] / length
    
    return vertex_normals
    

#10
def draw_rabbit(vertices, polygons):
    img = np.zeros((1000, 1000, 3), dtype=np.uint8)
    #14
    z_buffer = np.full((1000, 1000), np.inf)

    vertex_normal = vertex_normals(vertices, polygons)
    rotated_vertex_normals = []

    rotated_and_shifted_vertices = []
    for i in range(len(vertices)):
        vertex = vertices[i] 
        x, y, z = vertex
        norm_x, norm_y, norm_z = vertex_normal[i]
        new_norm_x, new_norm_y, new_norm_z = rotate_and_shift_rabbit(0, 0, 0, 0, -np.pi, 0, norm_x, norm_y, norm_z)
        new_x, new_y, new_z = rotate_and_shift_rabbit(0, -0.05, 0.12, 0, -np.pi, 0, x, y, z)
        rotated_and_shifted_vertices.append([new_x, new_y, new_z])
        rotated_vertex_normals.append([new_norm_x, new_norm_y, new_norm_z]) 

    for polygon in polygons:
        idx1 = polygon[0] - 1
        idx2 = polygon[1] - 1
        idx3 = polygon[2] - 1
            
        x0, y0, z0 = rotated_and_shifted_vertices[idx1]
        x1, y1, z1 = rotated_and_shifted_vertices[idx2]
        x2, y2, z2 = rotated_and_shifted_vertices[idx3]

        I0 = cos_of_light(vertex_normal[idx1])
        I1 = cos_of_light(vertex_normal[idx2])
        I2 = cos_of_light(vertex_normal[idx3])

        #11
        normal_vec = np.cross([x1 - x2, y1 - y2, z1 - z2], [x1 - x0, y1 - y0, z1 - z0])
        cos = cos_of_light(normal_vec)
        color = (-66*cos, -49*cos, -137*cos)
        if(cos < 0):
            draw_triangles(img, x0, x1, x2, y0, y1, y2, z0, z1, z2, z_buffer, color)
    
    image = Image.fromarray(img, mode='RGB')
    image = image.transpose(Image.FLIP_TOP_BOTTOM)
    image.save("img_rabbit_with_triangles.png")

#7
def barycentric_coordinates(x0, x, x1, x2, y0, y, y1, y2, znam):
    lambda0 = ((x - x2) * (y1 - y2) - (x1 - x2) * (y - y2)) / znam
    lambda1 = ((x0 - x2) * (y - y2) - (x - x2) * (y0 - y2)) / znam
    lambda2 = 1.0 - lambda0 - lambda1
    return lambda0, lambda1, lambda2

#8
def draw_triangles(img_triangles, x0, x1, x2, y0, y1, y2, z0, z1, z2, z_buffer, color):
    width, height = img_triangles.shape[:2]
    u0 = 800*x0/z0 + 500
    v0 = 800*y0/z0 + 500
    u1 = 800*x1/z0 + 500
    v1 = 800*y1/z0 + 500
    u2 = 800*x2/z0 + 500
    v2 = 800*y2/z0 + 500
    xmin = int(round(min(u0, u1, u2)))
    ymin = int(round(min(v0, v1, v2)))
    xmax = int(round(max(u0, u1, u2)))
    ymax = int(round(max(v0, v1, v2)))

    if (xmin < 0): xmin = 0
    if(ymin < 0): ymin = 0
    if(xmax > width - 1): xmax = width - 1
    if(ymax > height - 1): ymax = height - 1 

    #13
    znam = (u0 - u2) * (v1 - v2) - (u1 - u2) * (v0 - v2)
    for y in range(ymin, ymax + 1):
        for x in range(xmin, xmax + 1):
            k, m, n = barycentric_coordinates(u0, x, u1, u2, v0, y, v1, v2, znam)
            if(k >= 0 and m >= 0 and n >= 0):
                z_coord = k*z0 + m*z1 + n*z2
                if(z_coord < z_buffer[y, x]):
                    z_buffer[y, x] = z_coord
                    img_triangles[y, x] = color
    return img_triangles

#5
def read_polygons(filename):
    polygons = []
    spl = []

    file = open(filename, 'r')

    for line in file:
        if line.startswith('f '):  # вершины
            spl = [int(x.split('/')[0]) for x in line.split()[1:4]]
            polygons.append(spl)
    file.close()
    return polygons

#3
def read_vertex(filename):
    vertices = []

    file = open(filename, 'r')
    for line in file:
        if line.startswith('v '):  # вершины
            spl = list(map(float, line.split()[1:4]))
            vertices.append(spl)
    file.close()
    return vertices 

#3, 5
vertex = read_vertex('model_1.obj')
polygons = read_polygons('model_1.obj')

#10
draw_rabbit(vertex, polygons)